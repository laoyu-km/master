### 逻辑运算符运用示例
```JavaScript
// 示例1
var name = '';
console.log(name || '未找到数据');
```
```JavaScript
//应用2
 a.onclick = function(e) {
     // 判断是否IE低版本浏览器
     var event = e || window.event;
 }
```

###  纯函数实现可缓存性

```js
function setCache(fn) {
    var cache = {};

    return function() {
        var args = JSON.stringify(arguments);

        cache[args] = cache[args] ?
            cache[args] + ' 来自缓存' :
            fn.apply(fn, arguments);
        return cache[args];
    }
}

var app = setCache(function() {
    var argLen = arguments.length,
        item,
        res = 0;

    for (var i = 0; i < argLen; i++) {
        item = arguments[i];
        res += item;
    }

    return res;
});

console.log(app(1, 2));
console.log(app(1, 2));
console.log(app(5, 10));
console.log(app(5, 10));
```



### 深度Clone ES3实现

```js
function deepClone(tar, origin) {
    var tar = tar || {},
        arrType = '[object Array]',
        toStr = Object.prototype.toString;

    for (var key in origin) {
        if (origin.hasOwnProperty(key)) {
            if (typeof origin[key] === 'object') {
                tar[key] = toStr.call(origin[key]) === arrType ? [] : {};
                deepClone(tar[key], origin[key]);
            } else {
                tar[key] = origin[key];
            }
        }
    }
    return tar;
}
```



### 重写bind()

```js
Function.prototype.myBind = function(tarObj) {
    var _this = this;
    var paremeter = Array.prototype.slice.call(arguments, 1);
    var newFn = function() {};
    var bound = function() {
        var newParemeters = paremeter.concat(Array.prototype.slice.call(arguments));
        return _this.apply(this instanceof newFn ? this : tarObj, newParemeters);
    };

    if (this.prototype) {
        newFn.prototype = this.prototype;
    }

    bound.prototype = new newFn();

    return bound;
};
```




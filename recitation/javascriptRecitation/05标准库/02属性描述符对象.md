# 4. 属性描述对象

## 概述

- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，这个内部数据结构称为“属性描述对象”（attributes object），属性描述对象提供6个元属性

- value: 该属性的属性值，默认为undefined

- writable: 是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true

- enumerable: 是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性

- configurable: configurable是一个布尔值，表示属性的可配置性，默认为true。如果设为false，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。

- get: 是一个函数，表示该属性的取值函数（getter），默认为undefined,

- set: 是一个函数，表示该属性的存值函数（setter），默认为undefined

## Object.getOwnPropertyDescriptor()

- 参数： 目标对象, 一个字符串对应目标对象的某个属性名

- return: 返回属性描述对象

- function: 获取属性描述对象

- 调用方式: `Object.getOwnPropertyDescriptor(obj, propertyName)`

- tip: 只能用于对象自身的属性，不能用于继承的属性

## Object.getOwnPropertyNames()

- 参数： 目标对象

- return: array

- function: 返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。

- 调用方式: `Object.getOwnPropertyNames(obj)`;

- tip: 只能获得对象自身的属性，不能用于继承的属性

## Object.defineProperty()

- 参数： 目标对象, 属性名, 属性描述对象

- return: 目标对象

- function: 允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象

- 调用方式: `Object.defineProperty(obj, 'propertyName', 属性描述对象)`;

- tip: 如果属性已经存在，Object.defineProperty()方法相当于更新该属性的属性描述对象

- tip2: 一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。

  ```js
    var obj = Object.defineProperty({}, 'name', {
      value: 'jayden',
      writable: true,
      enumerable: true,
      configurable: true
    });
  ```

## Object.defineProperties()

- 参数： 目标对象, {属性名: 属性描述对象，。。。}

- return: 目标对象

- function: 一次性定义或修改多个属性

- 调用方式: `Object.defineProperties(obj, {name1: 属性描述对象, name2: 属性描述对象, ...})`;

- tip: 如果属性已经存在，Object.defineProperties()方法相当于更新该属性的属性描述对象

- tip2: 一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错

  ```js
    var obj = Object.defineProperties({}, {
      name: {
        value: 'jayden',
        writable: true,
        enumerable: true,
        configurable: true
      },
      age: {
        value: 16,
        writable: true,
        enumerable: true,
        configurable: true
      },
      sexAge: {
        get: function() {
          return this.age - 10;
        },
        set: function(value) {
          this.age = value + 10;
        }
        enumerable: true,
        configurable: true
      }
    });
  ```

## Object.prototype.propertyIsEnumerable()

- 参数：属性名

- return: boolean

- function: 返回一个布尔值，用来判断某个属性是否可遍历

- 调用方式: `obj.propertyIsEnumerable(propertyName)`;

- tip: 这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false

## 元属性

### value

- 是目标属性的值

### writable

- writable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变

- 正常模式下，对writable为false的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对该属性重新赋予一个同样的值

- 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性,如果是严格模式，这样做还会抛出一个错误

- 有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。

  ```js
    var proto = Object.defineProperty({}, 'name', {
      value: 'jayden',
      writable: false,
      enumerable: true,
      configurable: true
    });

    var obj = Object.create(proto);
    obj.name = 'alexis';

    console.log(obj) // jayden

    Object.defineProperty(obj, 'name', {
      value: 'elle',
      writable: true,
      enumerable: true,
      configurable: true
    });

    console.log(obj.name); // elle
  ```

### enumerable

- （可遍历性）返回一个布尔值，表示目标属性是否可遍历

- 只有可遍历的属性，才会被for...in循环遍历，同时还规定toString这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了for...in循环的可用性。

- 如果一个属性的enumerable为false，下面三个操作不会取到该属性

  - for..in循环

  - Object.keys方法

  - JSON.stringify方法

- enumerable可以用来设置“秘密”属性

- 如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法

- JSON.stringify方法会排除enumerable为false的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的enumerable设为false

### configurable

- configurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象

- 也就是说，configurable为false时，writable、enumerable和configurable都不能被修改了，结果都报错

- 注意，configurable为false时，writable属性只有在false改为true时会报错，true改为false是允许的

- value属性的情况比较特殊。只要writable和configurable有一个为true，就允许改动value

- 另外，writable为false时，直接对目标属性赋值，不报错，但不会成功。如果是严格模式，还会报错。

- 可配置性决定了目标属性是否可以被删除（delete）

### 存取器

- 属性还可以用存取器（accessor）定义

- 其中，存值函数称为setter，使用属性描述对象的set属性

- 取值函数称为getter，使用属性描述对象的get属性

- 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数, 利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。

- 取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）

- 一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错 

- 存取器往往用于，属性的值依赖对象内部数据的场合

- JavaScript 还提供了存取器的两种写法

  ```js
  // 写法1
  var obj = {};
  Object.defineProperties(obj, {
    _n: {
      value: 2,
      writable: true,
      enmuerable: true,
      configurable: true
    },
    count: {
      get: function() {
        return this._n++;
      },
      set: function(value) {
        if (this._n++ < value) {
          this._n = value;
        } else {
          throw new Error('new value must > ' + this._n);
        }
      },
      enumerable: true,
      configurable: true
    }
  });

  // 写法2
  var obj = {
    _n: 2,
    get count() {
      return this._n++;
    },
    set count(value) {
      if(this._n < value) {
        this._n = value;
      } else {
        throw new Error('new value must > ' + this._n);
      }
    }
  };
  ```

## 对象的拷贝

- 我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现

  ```js
    var copyObj = function(to, from) {
      for (property in from) {
        if (from.hasOwnProperty(property)) {
          to[property] = from[property];
        }
      }
      return to;
    }
    var obj = {};
    copyObj(obj, {get name() {return 'jayden'}}) // {name: 'jayden'}
  ```

- 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值

- 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性

  ```js
    var copyObj = function(to, from) {
      for (property in from) {
        if(from.hasOwnProperty(property)) {
          Object.defineProperty(to, property, Object.getOwnPropertyDescriptor(from, property));
        }
      }
      return to;
    }
    copyObj({}, {get name() {return 'jadyen'}}); //get name: f name()
  ```

## 控制对象状态

- 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze

### Object.preventExtensions()

- 参数：目标对象

- return: 目标对象

- function: 可以使得一个对象无法再添加新的属性

- 调用方式: `Object.preventExtensions(obj)`;

- tip: 

### Object.isExtensible()

- 参数：目标对象

- return: boolean

- function: 检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性

- 调用方式: `Object.isExtensible(obj)`;

- tip: 

### Object.seal()

- 参数：目标对象

- return: 目标对象

- function: 使得一个对象既无法添加新属性，也无法删除旧属性

- 调用方式: `Object.seal(obj)`;

- tip: 实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。

- tip2: Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值, 因为此时p属性的可写性由writable决定

### Object.isSealed()

- 参数：目标对象

- return: boolean

- function: 方法用于检查一个对象是否使用了Object.seal方法

- 调用方式: `Object.isSealed(obj)`;

- tip: 使用 Object.seal 方法后，Object.isExtensible 返回false

### Object.freeze()

- 参数：目标对象

- return: 目标对象

- function: 方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

- 调用方式: `Object.freeze(obj)`;

- tip: 修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错

### Object.isFrozen()

- 参数：目标对象

- return: boolean

- function: 用于检查一个对象是否使用了Object.freeze方法

- 调用方式: `Object.isFrozen(obj)`;

- tip: 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。

- tip2: Object.isFrozen的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值

### 局限性

- 1. 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性

  ```js
  var obj = {};
  Object.preventExtensions(obj);

  var proto = Object.getPrototypeOf(obj);

  proto.name = 'jayden';

  console.log(obj.name); // jayden
  ```

- 一种解决方案是，把obj的原型也冻结住

- 2. 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象(地址)，而不能冻结对象本身的内容(地址内部的值)

// ES6 函数的扩张

// 1. 函数参数的默认值

// ES6函数默认值基本用法

//// ES6之前的函数设置默认值以及注意事项

//// 参数重名问题

//// 参数默认声明

//// 参数默认值惰性求值

// 与解构赋值默认值结合使用

//// 参数默认值可以与解构赋值的默认值，结合起来使用

//// 函数参数的默认值生效以后，参数解构赋值依然会进行

//// 基于上述进行练习，下面两种函数写法有什么差别

// 参数默认值的位置

//// 通常情况下，定义了默认值的参数，应该是函数的尾参数

//// 如果非尾部的参数设置默认值，实际上这个参数是没法省略的

//// 显式输入undefined  将触发该参数等于默认值，null则没有这个效果

// 函数的 length 属性

//// 指定了默认值后，length属性将失真

//// 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了, rest 参数也不会计入length属性

//// 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了

// 默认值参数作用域

//// 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）

//// 等到初始化结束，这个作用域就会消失

//// 这种语法行为，在不设置参数默认值时，是不会出现的

// 应用

//// 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误

//// 参数mustBeProvided的默认值等于throwIfMissing函数的运行结果表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行

//// 可以将参数默认值设为undefined，表明这个参数是可以省略的

// rest 参数

//// ES6 引入 rest 参数（形式为...变量名）,用于获取函数的多余参数，这样就不需要使用arguments对象了

//// rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中

//// rest 参数代替arguments变量的例子

//// arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.from先将其转为数组

//// rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用

//// 利用 rest 参数改写数组push方法的例子

//// rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错

//// 函数的length属性，不包括 rest 参数

// 严格模式

//// 从 ES5 开始，函数内部可以设定为严格模式 ////> 'use strict'

//// ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

//// 原因: 函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

//// 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式

//// 规避方法：(函数内部不行，函数外部来弄)

//// 1. 第一种是设定全局性的严格模式，这是合法的

//// 2. 把函数包在一个无参数的立即执行函数里面

// name 属性

//// 函数的name属性，返回该函数的函数名

//// 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准

//// ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名

//// 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字

//// Function构造函数返回的函数实例，name属性的值为anonymous

//// bind返回的函数，name属性值会加上bound前缀

// 箭头函数

// 基本用法

//// S6 允许使用“箭头”（=>）定义函数

//// 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分

//// 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。

//// 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错

//// 特例：let foo = () => {a: 1}; foo() // undefined ////> 原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值

//// 如果箭头函数只有一行语句，且不需要返回值, 就不用写大括号了

//// 箭头函数可以与变量解构结合使用

//// rest 参数与箭头函数结合的例子

// 使用注意点

// 1. 箭头函数没有自己的this对象

// 2. 不可以当作构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。

// 3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

// 4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数

//// 没有自己的this对象，内部的this就是定义时上层作用域中的this。也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。

//// 箭头函数实际上可以让this指向固定化，绑定this使得它不再可变，这种特性很有利于封装回调函数

//// 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target

//// 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向

// 不适用场合

//// 由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数

//// 第一个场合是定义对象的方法，且该方法内部包括this

//// 箭头函数没有this，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致箭头函数定义时的作用域就是全局作用域

//// 箭头函数定义了对象方法， JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给obj.m，这导致箭头函数内部的this指向全局对象，所以obj.m()输出的是全局空间的21，而不是对象内部的42

//// 第二个场合是需要动态this的时候，也不应使用箭头函数

//// 如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。

// 嵌套的箭头函数

//// 部署管道机制（pipeline）的例子

//// 改写 λ 演算

// 尾调用优化

// 什么是尾调用

//// 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数(return fn(x))

//// 三种情况，都不属于尾调用

```js
  // 情况一
  function f(x){
    let y = g(x);
    return y;
  }

  // 情况二
  function f(x){
    return g(x) + 1;
  }

  // 情况三
  function f(x){
    g(x);
  }
  ```;

//// 调用不一定出现在函数尾部，只要是最后一步操作即可

// 尾调用优化

//// 调用栈: 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）

//// 尾调用优化: 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了, 即只保留内层函数的调用帧

//// 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”

// 尾递归

//// 函数调用自身，称为递归。如果尾调用自身，就称为尾递归

//// 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误

//// 计算n的阶乘使用尾递归

//// 尾递归实现Fibonacci 数列

//// ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存

// 递归函数的改写

//// 做到尾递归的方法，就是把所有用到的内部变量改写成函数的参数

//// 问题，内部变量改写成函数参数不太直观，两个方法解决

//// 1. 在尾递归函数之外，再提供一个正常形式的函数或者使用函数柯里化

//// 2. 采用 ES6 的函数默认值

//// 总结: 递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归

// 严格模式

//// ES6 的尾调用优化只在严格模式下开启，正常模式是无效的

//// 原因: 正常模式下，函数内部有两个变量，可以跟踪函数的调用栈

//// func.arguments：返回调用时函数的参数。
//// func.caller：返回调用当前函数的那个函数。

//// 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效

// 尾递归优化的实现

//// 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢

//// 原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”

//// 使用蹦床函数实现

//// tco函数的实现

// 函数参数的尾逗号

//// ES2017 允许函数的最后一个参数有尾逗号（trailing comma）

//// 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号

//// 原因：修改代码的时候，想为函数添加参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号

//// 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了

// Function.prototype.toString()

//// ES2019 对函数实例的toString()方法做出了修改， 明确要求返回一模一样的原始代码

//// 以前会省略注释和空格

// catch 命令的参数省略

//// 以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象

//// 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写

//// ES2019 做出了改变，允许catch语句省略参数。
